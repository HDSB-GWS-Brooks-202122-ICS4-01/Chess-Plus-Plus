import java.util.ArrayList;
import java.util.Arrays;

/**
 * Class for board data that is used by the A.I.
 * 
 * @author Akil Pathiranage
 * @version 1.0
 */
public class BoardInfo {
    byte[][] board;
    int[] passant;
    boolean[] hasMoved;
    String previousMove;
    int moveCount;
    int evaluate;
    int sortingValue = 0;

    byte whiteKingX;
    byte whiteKingY;

    byte blackKingX;
    byte blackKingY; 

    /**
     * Constructor for BoardInfo class.
     * @param board Positions of everything on the board.
     * @param passant An array of integers represnting the passant attribute for each pawn.
     * @param hasMoved An array of booleans representing the hasMoved attributes for kings and rooks. 
     * @param moveCount The current movecount on the board. 
     */
    public BoardInfo(byte[][] board, int[] passant, boolean[] hasMoved, int moveCount){
        this.moveCount = moveCount;
        this.board = board;
        this.passant = passant;
        this.hasMoved = hasMoved;
        this.previousMove = "";
    }
    
    
    

    /**
     * Method that moves a piece from one place to another. If the piece it is moving
     * to is occupied, it sets the scoring value of this board equal to the piece that was removed. 
     * @param id The id of the piece to move.
     * @param fromX X location from where the piece is moving.
     * @param fromY Y location from where the piece is moving.
     * @param toX X location to place the piece at.
     * @param toY Y location to place the piece at.
     */
    public void movePiece(byte id, int fromX, int fromY, int toX, int toY){
        if(board[toX][toY] != Constants.pieceIDs.EMPTY_CELL){
            sortingValue = Constants.ScoringIDs.scoringMap[board[toX][toY]];
            board[toX][toY] = id;
            board[fromX][fromY] = Constants.pieceIDs.EMPTY_CELL;
        } else {
            board[toX][toY] = id;
            board[fromX][fromY] = Constants.pieceIDs.EMPTY_CELL;
        }

    }

    /**
     * Method for deep copying a BoardInfo object. 
     * @return A new BoardInfo object that is a deep copy of the original. 
     */
    public BoardInfo copy(){
        BoardInfo copy = new BoardInfo(App.deepCopy(board), Arrays.copyOf(passant, passant.length), Arrays.copyOf(hasMoved, hasMoved.length), moveCount);
        copy.setKingPos(false, whiteKingX, whiteKingY);
        copy.setKingPos(true, blackKingX, blackKingY);
        return copy;
    }




    /**
     * Sets the previous move string. This string is used to determine which move led to a move to create the board.
     * If the string is null, that means that this board was not generated by the bot.
     * 
     * @param move The new string to set it to.
     */
    public void setPreviousMove(String move){
        previousMove = move;

    }

    /**
     * This method sets the king position attribute of the BoardInfo object, and also updates it's position on the board.
     * @param black Color of the king, true if the king is black, false if not.
     * @param x X location to put the king at.
     * @param y Y location to put the king at. 
     */
    public void setKingPos(boolean black, byte x, byte y){
        if(black){
            blackKingX = x;
            blackKingY = y;
            board[x][y] = Constants.pieceIDs.BLACK_KING;
        } else {
            whiteKingX = x;
            whiteKingY = y;
            board[x][y] = Constants.pieceIDs.WHITE_KING;
        }
    }


    /**
     * This method deep copies an ArrayList of type byte[]. 
     * 
     * @param original Original ArrayList to copy. 
     * @return An ArrayList<byte[]> object, that contains no references to the original.
     */
    public ArrayList<byte[]> copyArrayList(ArrayList<byte[]> original){
        ArrayList<byte[]> copied = new ArrayList<byte[]>();
        byte[] arr;
        for(int i = 0; i < original.size(); i++){

            arr = Arrays.copyOf(original.get(i), original.get(i).length);
            copied.add(arr);
        }

        return copied; 

    }
}
